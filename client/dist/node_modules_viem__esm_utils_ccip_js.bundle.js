"use strict";
(self["webpackChunkclient"] = self["webpackChunkclient"] || []).push([["node_modules_viem__esm_utils_ccip_js"],{

/***/ "./node_modules/viem/_esm/errors/ccip.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_esm/errors/ccip.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OffchainLookupError: () => (/* binding */ OffchainLookupError),
/* harmony export */   OffchainLookupResponseMalformedError: () => (/* binding */ OffchainLookupResponseMalformedError),
/* harmony export */   OffchainLookupSenderMismatchError: () => (/* binding */ OffchainLookupSenderMismatchError)
/* harmony export */ });
/* harmony import */ var _utils_stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stringify.js */ "./node_modules/viem/_esm/utils/stringify.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_esm/errors/base.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/_esm/errors/utils.js");



class OffchainLookupError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
        super(cause.shortMessage ||
            'An error occurred while fetching for an offchain result.', {
            cause,
            metaMessages: [
                ...(cause.metaMessages || []),
                cause.metaMessages?.length ? '' : [],
                'Offchain Gateway Call:',
                urls && [
                    '  Gateway URL(s):',
                    ...urls.map((url) => `    ${(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getUrl)(url)}`),
                ],
                `  Sender: ${sender}`,
                `  Data: ${data}`,
                `  Callback selector: ${callbackSelector}`,
                `  Extra data: ${extraData}`,
            ].flat(),
            name: 'OffchainLookupError',
        });
    }
}
class OffchainLookupResponseMalformedError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {
    constructor({ result, url }) {
        super('Offchain gateway response is malformed. Response data must be a hex value.', {
            metaMessages: [
                `Gateway URL: ${(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getUrl)(url)}`,
                `Response: ${(0,_utils_stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify)(result)}`,
            ],
            name: 'OffchainLookupResponseMalformedError',
        });
    }
}
class OffchainLookupSenderMismatchError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {
    constructor({ sender, to }) {
        super('Reverted sender address does not match target contract address (`to`).', {
            metaMessages: [
                `Contract address: ${to}`,
                `OffchainLookup sender address: ${sender}`,
            ],
            name: 'OffchainLookupSenderMismatchError',
        });
    }
}
//# sourceMappingURL=ccip.js.map

/***/ }),

/***/ "./node_modules/viem/_esm/utils/address/isAddressEqual.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_esm/utils/address/isAddressEqual.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAddressEqual: () => (/* binding */ isAddressEqual)
/* harmony export */ });
/* harmony import */ var _errors_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_esm/errors/address.js");
/* harmony import */ var _isAddress_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isAddress.js */ "./node_modules/viem/_esm/utils/address/isAddress.js");


function isAddressEqual(a, b) {
    if (!(0,_isAddress_js__WEBPACK_IMPORTED_MODULE_0__.isAddress)(a, { strict: false }))
        throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError({ address: a });
    if (!(0,_isAddress_js__WEBPACK_IMPORTED_MODULE_0__.isAddress)(b, { strict: false }))
        throw new _errors_address_js__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError({ address: b });
    return a.toLowerCase() === b.toLowerCase();
}
//# sourceMappingURL=isAddressEqual.js.map

/***/ }),

/***/ "./node_modules/viem/_esm/utils/ccip.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_esm/utils/ccip.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ccipRequest: () => (/* binding */ ccipRequest),
/* harmony export */   offchainLookup: () => (/* binding */ offchainLookup),
/* harmony export */   offchainLookupAbiItem: () => (/* binding */ offchainLookupAbiItem),
/* harmony export */   offchainLookupSignature: () => (/* binding */ offchainLookupSignature)
/* harmony export */ });
/* harmony import */ var _actions_public_call_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../actions/public/call.js */ "./node_modules/viem/_esm/actions/public/call.js");
/* harmony import */ var _errors_ccip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/ccip.js */ "./node_modules/viem/_esm/errors/ccip.js");
/* harmony import */ var _errors_request_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/request.js */ "./node_modules/viem/_esm/errors/request.js");
/* harmony import */ var _abi_decodeErrorResult_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abi/decodeErrorResult.js */ "./node_modules/viem/_esm/utils/abi/decodeErrorResult.js");
/* harmony import */ var _abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi/encodeAbiParameters.js */ "./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js");
/* harmony import */ var _address_isAddressEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./address/isAddressEqual.js */ "./node_modules/viem/_esm/utils/address/isAddressEqual.js");
/* harmony import */ var _data_concat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/concat.js */ "./node_modules/viem/_esm/utils/data/concat.js");
/* harmony import */ var _data_isHex_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data/isHex.js */ "./node_modules/viem/_esm/utils/data/isHex.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/viem/_esm/utils/stringify.js");









const offchainLookupSignature = '0x556f1830';
const offchainLookupAbiItem = {
    name: 'OffchainLookup',
    type: 'error',
    inputs: [
        {
            name: 'sender',
            type: 'address',
        },
        {
            name: 'urls',
            type: 'string[]',
        },
        {
            name: 'callData',
            type: 'bytes',
        },
        {
            name: 'callbackFunction',
            type: 'bytes4',
        },
        {
            name: 'extraData',
            type: 'bytes',
        },
    ],
};
async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
    const { args } = (0,_abi_decodeErrorResult_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrorResult)({
        data,
        abi: [offchainLookupAbiItem],
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'
        ? ccipRead.request
        : ccipRequest;
    try {
        if (!(0,_address_isAddressEqual_js__WEBPACK_IMPORTED_MODULE_1__.isAddressEqual)(to, sender))
            throw new _errors_ccip_js__WEBPACK_IMPORTED_MODULE_2__.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipRequest_({ data: callData, sender, urls });
        const { data: data_ } = await (0,_actions_public_call_js__WEBPACK_IMPORTED_MODULE_3__.call)(client, {
            blockNumber,
            blockTag,
            data: (0,_data_concat_js__WEBPACK_IMPORTED_MODULE_4__.concat)([
                callbackSelector,
                (0,_abi_encodeAbiParameters_js__WEBPACK_IMPORTED_MODULE_5__.encodeAbiParameters)([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
            ]),
            to,
        });
        return data_;
    }
    catch (err) {
        throw new _errors_ccip_js__WEBPACK_IMPORTED_MODULE_2__.OffchainLookupError({
            callbackSelector,
            cause: err,
            data,
            extraData,
            sender,
            urls,
        });
    }
}
async function ccipRequest({ data, sender, urls, }) {
    let error = new Error('An unknown error occurred.');
    for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes('{data}') ? 'GET' : 'POST';
        const body = method === 'POST' ? { data, sender } : undefined;
        try {
            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {
                body: JSON.stringify(body),
                method,
            });
            let result;
            if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                result = (await response.json()).data;
            }
            else {
                result = (await response.text());
            }
            if (!response.ok) {
                error = new _errors_request_js__WEBPACK_IMPORTED_MODULE_6__.HttpRequestError({
                    body,
                    details: result?.error
                        ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_7__.stringify)(result.error)
                        : response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url,
                });
                continue;
            }
            if (!(0,_data_isHex_js__WEBPACK_IMPORTED_MODULE_8__.isHex)(result)) {
                error = new _errors_ccip_js__WEBPACK_IMPORTED_MODULE_2__.OffchainLookupResponseMalformedError({
                    result,
                    url,
                });
                continue;
            }
            return result;
        }
        catch (err) {
            error = new _errors_request_js__WEBPACK_IMPORTED_MODULE_6__.HttpRequestError({
                body,
                details: err.message,
                url,
            });
        }
    }
    throw error;
}
//# sourceMappingURL=ccip.js.map

/***/ })

}]);
//# sourceMappingURL=node_modules_viem__esm_utils_ccip_js.bundle.js.map